{
  "version": 3,
  "sources": ["leaflet-global:leaflet", "../src/index.ts", "../src/HeatLayer.ts", "../src/HeatRenderer.ts"],
  "sourcesContent": ["module.exports = L;", "/**\n * leaflet-heatmap-layer\n *\n * A modern, maintained heatmap layer plugin for Leaflet\n * with automatic intensity scaling across zoom levels.\n */\n\nimport L from 'leaflet';\nimport { HeatLayer, type HeatLayerOptions, type HeatLatLng } from './HeatLayer';\nimport { HeatRenderer, type HeatRendererOptions, type HeatPoint } from './HeatRenderer';\n\n// Factory function: L.heatLayer(points, options)\nfunction heatLayer(latlngs: HeatLatLng[], options?: HeatLayerOptions): HeatLayer {\n  return new HeatLayer(latlngs, options);\n}\n\n// Extend L namespace for script-tag usage\ndeclare module 'leaflet' {\n  function heatLayer(latlngs: HeatLatLng[], options?: HeatLayerOptions): HeatLayer;\n}\n\n// Attach to L namespace for UMD/script-tag consumers\nconst _L = L as any;\n_L.heatLayer = heatLayer;\n\nexport {\n  HeatLayer,\n  HeatRenderer,\n  heatLayer,\n  type HeatLayerOptions,\n  type HeatLatLng,\n  type HeatRendererOptions,\n  type HeatPoint,\n};\n", "/**\n * HeatLayer \u2014 A Leaflet layer that renders a canvas-based heatmap.\n *\n * Handles map lifecycle (add/remove/zoom/pan), projects geographic coordinates\n * to pixel space, performs grid-clustering optimization, computes auto-max\n * intensity, and delegates rendering to HeatRenderer.\n */\n\nimport * as L from 'leaflet';\nimport { HeatRenderer, type HeatPoint } from './HeatRenderer';\n\nexport interface HeatLayerOptions extends L.LayerOptions {\n  /** Radius of each heat point in pixels (default: 25). */\n  radius?: number;\n  /** Additional blur in pixels (default: 15). */\n  blur?: number;\n  /** Minimum opacity of the heatmap (default: 0.05). */\n  minOpacity?: number;\n  /** Zoom level at which points reach maximum intensity (default: map maxZoom or 18). */\n  maxZoom?: number;\n  /**\n   * Manual maximum intensity cap. When omitted, computed automatically\n   * per redraw from all data points \u2014 this is the core fix over Leaflet.heat.\n   */\n  max?: number;\n  /** Color gradient stops (default: blue -> cyan -> lime -> yellow -> red). */\n  gradient?: Record<number, string>;\n  /** Duration in ms to crossfade between old and new heatmap on zoom (default: 250, 0 to disable). */\n  zoomCrossfadeDuration?: number;\n}\n\n/** Input point: [lat, lng] or [lat, lng, intensity], or L.LatLng (with optional .alt for intensity). */\nexport type HeatLatLng = [number, number] | [number, number, number] | L.LatLng;\n\nexport class HeatLayer extends L.Layer {\n  private _latlngs: HeatLatLng[];\n  private _options: HeatLayerOptions;\n  private _canvas: HTMLCanvasElement | null = null;\n  private _renderer: HeatRenderer | null = null;\n  private _frame: number | null = null;\n\n  // Zoom crossfade state\n  private _snapshotCanvas: HTMLCanvasElement | null = null;\n  private _zooming = false;\n  private _crossfadeTimer: number | null = null;\n\n  constructor(latlngs: HeatLatLng[], options?: HeatLayerOptions) {\n    super(options);\n    this._latlngs = latlngs;\n    this._options = {\n      radius: 25,\n      blur: 15,\n      minOpacity: 0.05,\n      ...options,\n    };\n  }\n\n  // ---- Leaflet Layer lifecycle ----\n\n  onAdd(map: L.Map): this {\n    this._map = map;\n\n    if (!this._canvas) {\n      this._createCanvas();\n    }\n\n    const pane = this.getPane();\n    if (pane && this._canvas) {\n      pane.appendChild(this._canvas);\n    }\n\n    map.on('moveend', this._onMoveEnd, this);\n    map.on('zoomanim', this._onZoomAnim, this);\n\n    this._onMoveEnd();\n    return this;\n  }\n\n  onRemove(map: L.Map): this {\n    // Cancel any pending animation frame to avoid zombie redraws\n    if (this._frame !== null) {\n      cancelAnimationFrame(this._frame);\n      this._frame = null;\n    }\n\n    // Clean up crossfade\n    this._clearCrossfade();\n    if (this._snapshotCanvas && this._snapshotCanvas.parentNode) {\n      this._snapshotCanvas.parentNode.removeChild(this._snapshotCanvas);\n    }\n    this._snapshotCanvas = null;\n\n    const pane = this.getPane();\n    if (pane && this._canvas) {\n      pane.removeChild(this._canvas);\n    }\n\n    map.off('moveend', this._onMoveEnd, this);\n    map.off('zoomanim', this._onZoomAnim, this);\n\n    return this;\n  }\n\n  // ---- Public API ----\n\n  /** Replace all data points and redraw. */\n  setLatLngs(latlngs: HeatLatLng[]): this {\n    this._latlngs = latlngs;\n    return this.redraw();\n  }\n\n  /** Add a single data point and redraw. */\n  addLatLng(latlng: HeatLatLng): this {\n    this._latlngs.push(latlng);\n    return this.redraw();\n  }\n\n  /** Update options and redraw. */\n  setOptions(options: Partial<HeatLayerOptions>): this {\n    Object.assign(this._options, options);\n    if (this._renderer) {\n      this._renderer.setOptions({\n        radius: this._options.radius,\n        blur: this._options.blur,\n        minOpacity: this._options.minOpacity,\n        gradient: this._options.gradient,\n      });\n    }\n    return this.redraw();\n  }\n\n  /** Return a LatLngBounds covering all data points. */\n  getBounds(): L.LatLngBounds {\n    const latlngs = this._latlngs.map((p) => this._toLatLng(p));\n    return L.latLngBounds(latlngs);\n  }\n\n  /** Schedule a redraw on the next animation frame. */\n  redraw(): this {\n    if (this._map && this._frame === null) {\n      this._frame = requestAnimationFrame(() => {\n        this._frame = null;\n        this._redraw();\n      });\n    }\n    return this;\n  }\n\n  // ---- Internal ----\n\n  private _createCanvas(): void {\n    this._canvas = document.createElement('canvas');\n    this._canvas.style.position = 'absolute';\n    this._canvas.style.pointerEvents = 'none';\n    this._canvas.style.willChange = 'transform';\n    this._canvas.style.transformOrigin = '0 0';\n\n    // Match original Leaflet.heat: mark as zoom-animated so Leaflet\n    // handles visibility correctly during zoom transitions.\n    const animated = this._map!.options.zoomAnimation && L.Browser.any3d;\n    L.DomUtil.addClass(\n      this._canvas,\n      'leaflet-zoom-' + (animated ? 'animated' : 'hide'),\n    );\n\n    this._renderer = new HeatRenderer(this._canvas, {\n      radius: this._options.radius,\n      blur: this._options.blur,\n      minOpacity: this._options.minOpacity,\n      gradient: this._options.gradient,\n    });\n  }\n\n  /** Handle moveend: reposition canvas and redraw. */\n  private _onMoveEnd(): void {\n    if (!this._map || !this._canvas) return;\n\n    const wasZooming = this._zooming;\n    this._zooming = false;\n\n    const duration = this._options.zoomCrossfadeDuration ?? 250;\n\n    // Snapshot old canvas content before we clear it (for zoom crossfade)\n    if (wasZooming && duration > 0) {\n      this._takeSnapshot();\n    }\n\n    const size = this._map.getSize();\n    const topLeft = this._map.containerPointToLayerPoint([0, 0]);\n\n    L.DomUtil.setPosition(this._canvas, topLeft);\n    this._renderer!.resize(size.x, size.y);\n\n    this._redraw();\n\n    // Start crossfade from snapshot to freshly rendered canvas\n    if (wasZooming && duration > 0) {\n      this._startCrossfade(duration);\n    }\n  }\n\n  /**\n   * Handle zoomanim: apply CSS transform for smooth zoom transitions.\n   *\n   * Computes where the canvas top-left would be in the new zoom's layer\n   * space, then applies translate + scale with transform-origin 0 0.\n   * Same approach as Leaflet's ImageOverlay._animateZoom.\n   */\n  private _onZoomAnim(e: L.ZoomAnimEvent): void {\n    if (!this._map || !this._canvas) return;\n\n    // Set the zooming flag here (not zoomstart) so crossfade only triggers\n    // when an actual zoom animation occurred.\n    this._zooming = true;\n\n    const map = this._map;\n    const scale = map.getZoomScale(e.zoom);\n\n    // The canvas's current position in layer space (set by _onMoveEnd)\n    const canvasPos = L.DomUtil.getPosition(this._canvas);\n    // Geographic location of the canvas top-left corner\n    const topLeftLatLng = map.layerPointToLatLng(canvasPos);\n\n    // Where this geographic point would be in the new zoom's layer space.\n    // Equivalent to map._latLngToNewLayerPoint(latlng, zoom, center):\n    //   project(latlng, zoom) - project(center, zoom) + size/2 + layerTopLeft\n    const layerTopLeft = map.containerPointToLayerPoint([0, 0]);\n    const newPos = map\n      .project(topLeftLatLng, e.zoom)\n      .subtract(map.project(e.center, e.zoom))\n      .add(map.getSize().divideBy(2))\n      .add(layerTopLeft)\n      .round();\n\n    L.DomUtil.setTransform(this._canvas, newPos, scale);\n  }\n\n  /** Copy the current canvas content + CSS transform to a snapshot canvas for crossfade. */\n  private _takeSnapshot(): void {\n    if (!this._canvas) return;\n\n    // Cancel any in-progress crossfade\n    this._clearCrossfade();\n\n    const canvas = this._canvas;\n\n    if (!this._snapshotCanvas) {\n      this._snapshotCanvas = document.createElement('canvas');\n      this._snapshotCanvas.style.position = 'absolute';\n      this._snapshotCanvas.style.pointerEvents = 'none';\n    }\n\n    const snap = this._snapshotCanvas;\n    snap.width = canvas.width;\n    snap.height = canvas.height;\n    snap.getContext('2d')!.drawImage(canvas, 0, 0);\n\n    // Copy the CSS transform (zoomanim transform) so snapshot appears in the same position\n    snap.style.transform = canvas.style.transform;\n    snap.style.transformOrigin = canvas.style.transformOrigin;\n    snap.style.opacity = '1';\n    snap.style.transition = '';\n\n    // Ensure snapshot is in the DOM and visually above the main canvas\n    if (canvas.parentNode) {\n      canvas.after(snap);\n    }\n  }\n\n  /** Fade the snapshot canvas to transparent over the given duration. */\n  private _startCrossfade(duration: number): void {\n    const snap = this._snapshotCanvas;\n    if (!snap) return;\n\n    snap.style.transition = `opacity ${duration}ms ease-out`;\n\n    // Force reflow so the transition triggers\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    snap.offsetHeight;\n\n    snap.style.opacity = '0';\n\n    this._crossfadeTimer = window.setTimeout(() => {\n      this._crossfadeTimer = null;\n      if (snap) {\n        snap.style.transition = '';\n      }\n    }, duration);\n  }\n\n  /** Cancel any in-progress crossfade. */\n  private _clearCrossfade(): void {\n    if (this._crossfadeTimer !== null) {\n      clearTimeout(this._crossfadeTimer);\n      this._crossfadeTimer = null;\n    }\n    if (this._snapshotCanvas) {\n      this._snapshotCanvas.style.transition = '';\n      this._snapshotCanvas.style.opacity = '0';\n    }\n  }\n\n  /**\n   * Core redraw logic:\n   * 1. Project all points to pixel space\n   * 2. Compute auto-max intensity (the key fix)\n   * 3. Grid-cluster points for performance\n   * 4. Normalize intensities and delegate to HeatRenderer\n   */\n  private _redraw(): void {\n    if (!this._map || !this._renderer || !this._canvas) return;\n\n    const map = this._map;\n    const size = map.getSize();\n    if (size.x === 0 || size.y === 0) return; // no container dimensions yet\n    const renderer = this._renderer;\n    const r = renderer.radius + renderer.blur;\n    const cellSize = Math.max(1, Math.floor(renderer.radius / 2));\n    const maxZoom = this._options.maxZoom ?? map.getMaxZoom();\n    const zoom = map.getZoom();\n\n    // Zoom scaling factor: at maxZoom intensity is full, at lower zooms it tapers\n    const v = 1 / Math.pow(2, Math.max(0, Math.min(maxZoom - zoom, 12)));\n\n    const bounds = map.getBounds();\n\n    // Pad visible bounds by the point radius so edge points are drawn correctly\n    const padLat = (r / size.y) * (bounds.getNorth() - bounds.getSouth());\n    const padLng = (r / size.x) * (bounds.getEast() - bounds.getWest());\n    const paddedBounds = L.latLngBounds(\n      [bounds.getSouth() - padLat, bounds.getWest() - padLng],\n      [bounds.getNorth() + padLat, bounds.getEast() + padLng],\n    );\n\n    // --- Pass 1: compute auto-max across ALL points (not just visible) ---\n    // This is the core fix for the intensity/zoom scaling bug.\n    let autoMax = 0;\n    if (this._options.max === undefined) {\n      for (const p of this._latlngs) {\n        const intensity = this._getIntensity(p);\n        const scaled = intensity * v;\n        if (scaled > autoMax) autoMax = scaled;\n      }\n    }\n    const effectiveMax = this._options.max ?? Math.max(autoMax, 1e-10);\n\n    // Layer-space origin of the viewport. Used to:\n    // 1. Convert layer points to canvas-local coordinates for drawing\n    // 2. Compute stable grid offsets (layer points don't shift on pan)\n    const topLeft = map.containerPointToLayerPoint([0, 0]);\n\n    // --- Pass 2: grid-cluster visible points ---\n    // Points are aggregated into grid cells of size `cellSize` pixels.\n    // Multiple points in the same cell are merged by weighted average.\n    //\n    // Grid keys use layer-space coordinates which are stable across pans.\n    // Without this, panning causes points to fall into different grid cells,\n    // producing flickering intensity changes.\n    const grid: Record<string, [number, number, number, number]> = {}; // key -> [sumX, sumY, sumIntensity, count]\n    const pixelPoints: HeatPoint[] = [];\n\n    for (const p of this._latlngs) {\n      const latlng = this._toLatLng(p);\n      if (!paddedBounds.contains(latlng)) continue;\n\n      // Layer point: stable across pans (used for grid cell assignment)\n      const lp = map.latLngToLayerPoint(latlng);\n\n      // Canvas-local coordinates for drawing\n      const x = lp.x - topLeft.x;\n      const y = lp.y - topLeft.y;\n      const intensity = this._getIntensity(p) * v;\n\n      // Grid cell key in stable layer space\n      const gx = Math.floor(lp.x / cellSize);\n      const gy = Math.floor(lp.y / cellSize);\n      const key = `${gx}:${gy}`;\n\n      const cell = grid[key];\n      if (cell) {\n        cell[0] += x * intensity; // weighted x (canvas-local)\n        cell[1] += y * intensity; // weighted y (canvas-local)\n        cell[2] += intensity;\n        cell[3]++;\n      } else {\n        grid[key] = [x * intensity, y * intensity, intensity, 1];\n      }\n    }\n\n    // Convert grid cells to normalized pixel points\n    for (const key in grid) {\n      const cell = grid[key];\n      const totalIntensity = cell[2];\n      if (totalIntensity === 0) continue;\n\n      pixelPoints.push([\n        cell[0] / totalIntensity, // weighted avg x (canvas-local)\n        cell[1] / totalIntensity, // weighted avg y (canvas-local)\n        totalIntensity / effectiveMax, // normalized intensity (0-1)\n      ]);\n    }\n\n    renderer.draw(pixelPoints);\n  }\n\n  /** Extract intensity from a point. Defaults to 1.0. */\n  private _getIntensity(p: HeatLatLng): number {\n    if (p instanceof L.LatLng) {\n      return (p as L.LatLng & { alt?: number }).alt ?? 1.0;\n    }\n    if (Array.isArray(p) && p.length >= 3) {\n      return (p as [number, number, number])[2];\n    }\n    return 1.0;\n  }\n\n  /** Convert any input point format to L.LatLng. */\n  private _toLatLng(p: HeatLatLng): L.LatLng {\n    if (p instanceof L.LatLng) return p;\n    return L.latLng(p[0], p[1]);\n  }\n}\n", "/**\n * HeatRenderer \u2014 a pure canvas heatmap renderer with no Leaflet dependency.\n *\n * Draws a heatmap onto an HTMLCanvasElement given pixel-space data points.\n * Handles gradient generation, blurred-circle stamping, and final colorization.\n */\n\nexport interface HeatRendererOptions {\n  /** Radius of each heat point in pixels. */\n  radius: number;\n  /** Additional blur applied to each point in pixels. */\n  blur: number;\n  /** Minimum opacity of the heatmap output (0\u20131). */\n  minOpacity: number;\n  /** Color gradient stops, keyed by position (0\u20131). */\n  gradient: Record<number, string>;\n}\n\n/** A pixel-space data point: [x, y, intensity]. */\nexport type HeatPoint = [number, number, number];\n\nconst DEFAULT_GRADIENT: Record<number, string> = {\n  0.4: 'blue',\n  0.6: 'cyan',\n  0.7: 'lime',\n  0.8: 'yellow',\n  1.0: 'red',\n};\n\nexport class HeatRenderer {\n  private _canvas: HTMLCanvasElement;\n  private _ctx: CanvasRenderingContext2D;\n\n  /** Pre-rendered blurred circle used as stamp for each point. */\n  private _circle: HTMLCanvasElement | null = null;\n  /** 256-entry RGBA palette derived from the gradient. */\n  private _palette: Uint8ClampedArray | null = null;\n\n  private _radius: number;\n  private _blur: number;\n  private _minOpacity: number;\n  private _gradient: Record<number, string>;\n\n  constructor(canvas: HTMLCanvasElement, options?: Partial<HeatRendererOptions>) {\n    this._canvas = canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) throw new Error('Could not get 2d context from canvas');\n    this._ctx = ctx;\n\n    this._radius = options?.radius ?? 25;\n    this._blur = options?.blur ?? 15;\n    this._minOpacity = options?.minOpacity ?? 0.05;\n    this._gradient = options?.gradient ?? DEFAULT_GRADIENT;\n  }\n\n  /** Update renderer options. Invalidates cached circle/palette as needed. */\n  setOptions(options: Partial<HeatRendererOptions>): void {\n    if (options.radius !== undefined || options.blur !== undefined) {\n      this._radius = options.radius ?? this._radius;\n      this._blur = options.blur ?? this._blur;\n      this._circle = null; // invalidate cached circle\n    }\n    if (options.gradient !== undefined) {\n      this._gradient = options.gradient;\n      this._palette = null; // invalidate cached palette\n    }\n    if (options.minOpacity !== undefined) {\n      this._minOpacity = options.minOpacity;\n    }\n  }\n\n  get radius(): number {\n    return this._radius;\n  }\n\n  get blur(): number {\n    return this._blur;\n  }\n\n  /**\n   * Resize the canvas to the given dimensions.\n   * This clears the canvas content.\n   */\n  resize(width: number, height: number): void {\n    this._canvas.width = width;\n    this._canvas.height = height;\n  }\n\n  /**\n   * Clear the canvas.\n   */\n  clear(): void {\n    this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n  }\n\n  /**\n   * Draw the heatmap from an array of pixel-space points.\n   *\n   * @param points Array of [x, y, intensity] tuples. Intensity should be\n   *   pre-normalized to the range 0\u20131 (the caller handles max computation).\n   */\n  draw(points: HeatPoint[]): void {\n    if (points.length === 0) {\n      this.clear();\n      return;\n    }\n\n    const circle = this._getCircle();\n    const fullRadius = this._radius + this._blur;\n\n    // --- Pass 1: stamp blurred circles in greyscale (alpha channel) ---\n    this.clear();\n\n    for (const [x, y, intensity] of points) {\n      this._ctx.globalAlpha = Math.max(intensity, this._minOpacity);\n      this._ctx.drawImage(circle, x - fullRadius, y - fullRadius);\n    }\n\n    // --- Pass 2: colorize using the gradient palette ---\n    this._colorize();\n  }\n\n  /**\n   * Get (or create) the pre-rendered blurred circle stamp.\n   * This is an offscreen canvas containing a single radial-gradient circle.\n   */\n  private _getCircle(): HTMLCanvasElement {\n    if (this._circle) return this._circle;\n\n    const r = this._radius;\n    const blur = this._blur;\n    const fullRadius = r + blur;\n    const diameter = fullRadius * 2;\n\n    const circle = document.createElement('canvas');\n    circle.width = diameter;\n    circle.height = diameter;\n    const ctx = circle.getContext('2d')!;\n\n    // Draw a soft radial gradient from opaque center to transparent edge\n    ctx.shadowOffsetX = diameter;\n    ctx.shadowOffsetY = diameter;\n    ctx.shadowBlur = blur;\n    ctx.shadowColor = 'black';\n\n    ctx.beginPath();\n    ctx.arc(fullRadius - diameter, fullRadius - diameter, r, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.fill();\n\n    this._circle = circle;\n    return circle;\n  }\n\n  /**\n   * Get (or create) the 256-entry RGBA color palette from the gradient.\n   */\n  private _getPalette(): Uint8ClampedArray {\n    if (this._palette) return this._palette;\n\n    // Draw the gradient onto a 1\u00D7256 canvas and read back pixel data\n    const paletteCanvas = document.createElement('canvas');\n    paletteCanvas.width = 256;\n    paletteCanvas.height = 1;\n    const ctx = paletteCanvas.getContext('2d')!;\n\n    const grad = ctx.createLinearGradient(0, 0, 256, 0);\n    for (const [stop, color] of Object.entries(this._gradient)) {\n      grad.addColorStop(Number(stop), color);\n    }\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, 256, 1);\n\n    this._palette = ctx.getImageData(0, 0, 256, 1).data as unknown as Uint8ClampedArray;\n    return this._palette;\n  }\n\n  /**\n   * Colorize the current canvas content.\n   * Reads the alpha channel of each pixel (which encodes heat intensity from\n   * the greyscale stamp pass), and replaces it with the corresponding color\n   * from the gradient palette.\n   */\n  private _colorize(): void {\n    const w = this._canvas.width;\n    const h = this._canvas.height;\n    if (w === 0 || h === 0) return;\n\n    const imageData = this._ctx.getImageData(0, 0, w, h);\n    const pixels = imageData.data;\n    const palette = this._getPalette();\n\n    for (let i = 0, len = pixels.length; i < len; i += 4) {\n      // The alpha value (0\u2013255) from the greyscale pass indexes into the palette\n      const alpha = pixels[i + 3];\n      if (alpha === 0) continue;\n\n      const paletteOffset = alpha * 4;\n      pixels[i] = palette[paletteOffset];       // R\n      pixels[i + 1] = palette[paletteOffset + 1]; // G\n      pixels[i + 2] = palette[paletteOffset + 2]; // B\n      // Keep original alpha \u2014 it encodes the soft intensity falloff from the\n      // blurred circle stamp. Replacing it with palette alpha (typically 255\n      // for solid gradient colors) would make every pixel fully opaque.\n    }\n\n    this._ctx.putImageData(imageData, 0, 0);\n  }\n}\n"],
  "mappings": "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",
  "names": ["L", "L"]
}
